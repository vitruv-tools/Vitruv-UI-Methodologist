{"ast":null,"code":"import React, { useCallback } from 'react';\nimport { useStore, useNodeId, getNodesBounds, internalsSymbol, Position } from '@reactflow/core';\nimport cc from 'classcat';\nimport { shallow } from 'zustand/shallow';\nimport { createPortal } from 'react-dom';\nconst selector = state => state.domNode?.querySelector('.react-flow__renderer');\nfunction NodeToolbarPortal(_ref) {\n  let {\n    children\n  } = _ref;\n  const wrapperRef = useStore(selector);\n  if (!wrapperRef) {\n    return null;\n  }\n  return createPortal(children, wrapperRef);\n}\nconst nodeEqualityFn = (a, b) => a?.positionAbsolute?.x === b?.positionAbsolute?.x && a?.positionAbsolute?.y === b?.positionAbsolute?.y && a?.width === b?.width && a?.height === b?.height && a?.selected === b?.selected && a?.[internalsSymbol]?.z === b?.[internalsSymbol]?.z;\nconst nodesEqualityFn = (a, b) => {\n  return a.length === b.length && a.every((node, i) => nodeEqualityFn(node, b[i]));\n};\nconst storeSelector = state => ({\n  transform: state.transform,\n  nodeOrigin: state.nodeOrigin,\n  selectedNodesCount: state.getNodes().filter(node => node.selected).length\n});\nfunction getTransform(nodeRect, transform, position, offset, align) {\n  let alignmentOffset = 0.5;\n  if (align === 'start') {\n    alignmentOffset = 0;\n  } else if (align === 'end') {\n    alignmentOffset = 1;\n  }\n  // position === Position.Top\n  // we set the x any y position of the toolbar based on the nodes position\n  let pos = [(nodeRect.x + nodeRect.width * alignmentOffset) * transform[2] + transform[0], nodeRect.y * transform[2] + transform[1] - offset];\n  // and than shift it based on the alignment. The shift values are in %.\n  let shift = [-100 * alignmentOffset, -100];\n  switch (position) {\n    case Position.Right:\n      pos = [(nodeRect.x + nodeRect.width) * transform[2] + transform[0] + offset, (nodeRect.y + nodeRect.height * alignmentOffset) * transform[2] + transform[1]];\n      shift = [0, -100 * alignmentOffset];\n      break;\n    case Position.Bottom:\n      pos[1] = (nodeRect.y + nodeRect.height) * transform[2] + transform[1] + offset;\n      shift[1] = 0;\n      break;\n    case Position.Left:\n      pos = [nodeRect.x * transform[2] + transform[0] - offset, (nodeRect.y + nodeRect.height * alignmentOffset) * transform[2] + transform[1]];\n      shift = [-100, -100 * alignmentOffset];\n      break;\n  }\n  return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\nfunction NodeToolbar(_ref2) {\n  let {\n    nodeId,\n    children,\n    className,\n    style,\n    isVisible,\n    position = Position.Top,\n    offset = 10,\n    align = 'center',\n    ...rest\n  } = _ref2;\n  const contextNodeId = useNodeId();\n  const nodesSelector = useCallback(state => {\n    const nodeIds = Array.isArray(nodeId) ? nodeId : [nodeId || contextNodeId || ''];\n    return nodeIds.reduce((acc, id) => {\n      const node = state.nodeInternals.get(id);\n      if (node) {\n        acc.push(node);\n      }\n      return acc;\n    }, []);\n  }, [nodeId, contextNodeId]);\n  const nodes = useStore(nodesSelector, nodesEqualityFn);\n  const {\n    transform,\n    nodeOrigin,\n    selectedNodesCount\n  } = useStore(storeSelector, shallow);\n  const isActive = typeof isVisible === 'boolean' ? isVisible : nodes.length === 1 && nodes[0].selected && selectedNodesCount === 1;\n  if (!isActive || !nodes.length) {\n    return null;\n  }\n  const nodeRect = getNodesBounds(nodes, nodeOrigin);\n  const zIndex = Math.max(...nodes.map(node => (node[internalsSymbol]?.z || 1) + 1));\n  const wrapperStyle = {\n    position: 'absolute',\n    transform: getTransform(nodeRect, transform, position, offset, align),\n    zIndex,\n    ...style\n  };\n  return React.createElement(NodeToolbarPortal, null, React.createElement(\"div\", {\n    style: wrapperStyle,\n    className: cc(['react-flow__node-toolbar', className]),\n    ...rest\n  }, children));\n}\nexport { NodeToolbar };","map":{"version":3,"names":["React","useCallback","useStore","useNodeId","getNodesBounds","internalsSymbol","Position","cc","shallow","createPortal","selector","state","domNode","querySelector","NodeToolbarPortal","_ref","children","wrapperRef","nodeEqualityFn","a","b","positionAbsolute","x","y","width","height","selected","z","nodesEqualityFn","length","every","node","i","storeSelector","transform","nodeOrigin","selectedNodesCount","getNodes","filter","getTransform","nodeRect","position","offset","align","alignmentOffset","pos","shift","Right","Bottom","Left","NodeToolbar","_ref2","nodeId","className","style","isVisible","Top","rest","contextNodeId","nodesSelector","nodeIds","Array","isArray","reduce","acc","id","nodeInternals","get","push","nodes","isActive","zIndex","Math","max","map","wrapperStyle","createElement"],"sources":["/Users/mohamadali/Vitruv-UI-Methodologist/node_modules/@reactflow/node-toolbar/dist/esm/index.mjs"],"sourcesContent":["import React, { useCallback } from 'react';\nimport { useStore, useNodeId, getNodesBounds, internalsSymbol, Position } from '@reactflow/core';\nimport cc from 'classcat';\nimport { shallow } from 'zustand/shallow';\nimport { createPortal } from 'react-dom';\n\nconst selector = (state) => state.domNode?.querySelector('.react-flow__renderer');\nfunction NodeToolbarPortal({ children }) {\n    const wrapperRef = useStore(selector);\n    if (!wrapperRef) {\n        return null;\n    }\n    return createPortal(children, wrapperRef);\n}\n\nconst nodeEqualityFn = (a, b) => a?.positionAbsolute?.x === b?.positionAbsolute?.x &&\n    a?.positionAbsolute?.y === b?.positionAbsolute?.y &&\n    a?.width === b?.width &&\n    a?.height === b?.height &&\n    a?.selected === b?.selected &&\n    a?.[internalsSymbol]?.z === b?.[internalsSymbol]?.z;\nconst nodesEqualityFn = (a, b) => {\n    return a.length === b.length && a.every((node, i) => nodeEqualityFn(node, b[i]));\n};\nconst storeSelector = (state) => ({\n    transform: state.transform,\n    nodeOrigin: state.nodeOrigin,\n    selectedNodesCount: state.getNodes().filter((node) => node.selected).length,\n});\nfunction getTransform(nodeRect, transform, position, offset, align) {\n    let alignmentOffset = 0.5;\n    if (align === 'start') {\n        alignmentOffset = 0;\n    }\n    else if (align === 'end') {\n        alignmentOffset = 1;\n    }\n    // position === Position.Top\n    // we set the x any y position of the toolbar based on the nodes position\n    let pos = [\n        (nodeRect.x + nodeRect.width * alignmentOffset) * transform[2] + transform[0],\n        nodeRect.y * transform[2] + transform[1] - offset,\n    ];\n    // and than shift it based on the alignment. The shift values are in %.\n    let shift = [-100 * alignmentOffset, -100];\n    switch (position) {\n        case Position.Right:\n            pos = [\n                (nodeRect.x + nodeRect.width) * transform[2] + transform[0] + offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * transform[2] + transform[1],\n            ];\n            shift = [0, -100 * alignmentOffset];\n            break;\n        case Position.Bottom:\n            pos[1] = (nodeRect.y + nodeRect.height) * transform[2] + transform[1] + offset;\n            shift[1] = 0;\n            break;\n        case Position.Left:\n            pos = [\n                nodeRect.x * transform[2] + transform[0] - offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * transform[2] + transform[1],\n            ];\n            shift = [-100, -100 * alignmentOffset];\n            break;\n    }\n    return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\nfunction NodeToolbar({ nodeId, children, className, style, isVisible, position = Position.Top, offset = 10, align = 'center', ...rest }) {\n    const contextNodeId = useNodeId();\n    const nodesSelector = useCallback((state) => {\n        const nodeIds = Array.isArray(nodeId) ? nodeId : [nodeId || contextNodeId || ''];\n        return nodeIds.reduce((acc, id) => {\n            const node = state.nodeInternals.get(id);\n            if (node) {\n                acc.push(node);\n            }\n            return acc;\n        }, []);\n    }, [nodeId, contextNodeId]);\n    const nodes = useStore(nodesSelector, nodesEqualityFn);\n    const { transform, nodeOrigin, selectedNodesCount } = useStore(storeSelector, shallow);\n    const isActive = typeof isVisible === 'boolean' ? isVisible : nodes.length === 1 && nodes[0].selected && selectedNodesCount === 1;\n    if (!isActive || !nodes.length) {\n        return null;\n    }\n    const nodeRect = getNodesBounds(nodes, nodeOrigin);\n    const zIndex = Math.max(...nodes.map((node) => (node[internalsSymbol]?.z || 1) + 1));\n    const wrapperStyle = {\n        position: 'absolute',\n        transform: getTransform(nodeRect, transform, position, offset, align),\n        zIndex,\n        ...style,\n    };\n    return (React.createElement(NodeToolbarPortal, null,\n        React.createElement(\"div\", { style: wrapperStyle, className: cc(['react-flow__node-toolbar', className]), ...rest }, children)));\n}\n\nexport { NodeToolbar };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}