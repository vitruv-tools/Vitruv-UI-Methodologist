{"ast":null,"code":"import React, { memo, useRef, useEffect } from 'react';\nimport cc from 'classcat';\nimport { drag } from 'd3-drag';\nimport { select } from 'd3-selection';\nimport { useNodeId, useStoreApi, useGetPointerPosition, clamp } from '@reactflow/core';\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n  ResizeControlVariant[\"Line\"] = \"line\";\n  ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\n\n// returns an array of two numbers (0, 1 or -1) representing the direction of the resize\n// 0 = no change, 1 = increase, -1 = decrease\nfunction getDirection(_ref) {\n  let {\n    width,\n    prevWidth,\n    height,\n    prevHeight,\n    invertX,\n    invertY\n  } = _ref;\n  const deltaWidth = width - prevWidth;\n  const deltaHeight = height - prevHeight;\n  const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n  if (deltaWidth && invertX) {\n    direction[0] = direction[0] * -1;\n  }\n  if (deltaHeight && invertY) {\n    direction[1] = direction[1] * -1;\n  }\n  return direction;\n}\nconst initPrevValues = {\n  width: 0,\n  height: 0,\n  x: 0,\n  y: 0\n};\nconst initStartValues = {\n  ...initPrevValues,\n  pointerX: 0,\n  pointerY: 0,\n  aspectRatio: 1\n};\nfunction ResizeControl(_ref2) {\n  let {\n    nodeId,\n    position,\n    variant = ResizeControlVariant.Handle,\n    className,\n    style = {},\n    children,\n    color,\n    minWidth = 10,\n    minHeight = 10,\n    maxWidth = Number.MAX_VALUE,\n    maxHeight = Number.MAX_VALUE,\n    keepAspectRatio = false,\n    shouldResize,\n    onResizeStart,\n    onResize,\n    onResizeEnd\n  } = _ref2;\n  const contextNodeId = useNodeId();\n  const id = typeof nodeId === 'string' ? nodeId : contextNodeId;\n  const store = useStoreApi();\n  const resizeControlRef = useRef(null);\n  const startValues = useRef(initStartValues);\n  const prevValues = useRef(initPrevValues);\n  const getPointerPosition = useGetPointerPosition();\n  const defaultPosition = variant === ResizeControlVariant.Line ? 'right' : 'bottom-right';\n  const controlPosition = position ?? defaultPosition;\n  useEffect(() => {\n    if (!resizeControlRef.current || !id) {\n      return;\n    }\n    const selection = select(resizeControlRef.current);\n    const enableX = controlPosition.includes('right') || controlPosition.includes('left');\n    const enableY = controlPosition.includes('bottom') || controlPosition.includes('top');\n    const invertX = controlPosition.includes('left');\n    const invertY = controlPosition.includes('top');\n    const dragHandler = drag().on('start', event => {\n      const node = store.getState().nodeInternals.get(id);\n      const {\n        xSnapped,\n        ySnapped\n      } = getPointerPosition(event);\n      prevValues.current = {\n        width: node?.width ?? 0,\n        height: node?.height ?? 0,\n        x: node?.position.x ?? 0,\n        y: node?.position.y ?? 0\n      };\n      startValues.current = {\n        ...prevValues.current,\n        pointerX: xSnapped,\n        pointerY: ySnapped,\n        aspectRatio: prevValues.current.width / prevValues.current.height\n      };\n      onResizeStart?.(event, {\n        ...prevValues.current\n      });\n    }).on('drag', event => {\n      const {\n        nodeInternals,\n        triggerNodeChanges\n      } = store.getState();\n      const {\n        xSnapped,\n        ySnapped\n      } = getPointerPosition(event);\n      const node = nodeInternals.get(id);\n      if (node) {\n        const changes = [];\n        const {\n          pointerX: startX,\n          pointerY: startY,\n          width: startWidth,\n          height: startHeight,\n          x: startNodeX,\n          y: startNodeY,\n          aspectRatio\n        } = startValues.current;\n        const {\n          x: prevX,\n          y: prevY,\n          width: prevWidth,\n          height: prevHeight\n        } = prevValues.current;\n        const distX = Math.floor(enableX ? xSnapped - startX : 0);\n        const distY = Math.floor(enableY ? ySnapped - startY : 0);\n        let width = clamp(startWidth + (invertX ? -distX : distX), minWidth, maxWidth);\n        let height = clamp(startHeight + (invertY ? -distY : distY), minHeight, maxHeight);\n        if (keepAspectRatio) {\n          const nextAspectRatio = width / height;\n          const isDiagonal = enableX && enableY;\n          const isHorizontal = enableX && !enableY;\n          const isVertical = enableY && !enableX;\n          width = nextAspectRatio <= aspectRatio && isDiagonal || isVertical ? height * aspectRatio : width;\n          height = nextAspectRatio > aspectRatio && isDiagonal || isHorizontal ? width / aspectRatio : height;\n          if (width >= maxWidth) {\n            width = maxWidth;\n            height = maxWidth / aspectRatio;\n          } else if (width <= minWidth) {\n            width = minWidth;\n            height = minWidth / aspectRatio;\n          }\n          if (height >= maxHeight) {\n            height = maxHeight;\n            width = maxHeight * aspectRatio;\n          } else if (height <= minHeight) {\n            height = minHeight;\n            width = minHeight * aspectRatio;\n          }\n        }\n        const isWidthChange = width !== prevWidth;\n        const isHeightChange = height !== prevHeight;\n        if (invertX || invertY) {\n          const x = invertX ? startNodeX - (width - startWidth) : startNodeX;\n          const y = invertY ? startNodeY - (height - startHeight) : startNodeY;\n          // only transform the node if the width or height changes\n          const isXPosChange = x !== prevX && isWidthChange;\n          const isYPosChange = y !== prevY && isHeightChange;\n          if (isXPosChange || isYPosChange) {\n            const positionChange = {\n              id: node.id,\n              type: 'position',\n              position: {\n                x: isXPosChange ? x : prevX,\n                y: isYPosChange ? y : prevY\n              }\n            };\n            changes.push(positionChange);\n            prevValues.current.x = positionChange.position.x;\n            prevValues.current.y = positionChange.position.y;\n          }\n        }\n        if (isWidthChange || isHeightChange) {\n          const dimensionChange = {\n            id: id,\n            type: 'dimensions',\n            updateStyle: true,\n            resizing: true,\n            dimensions: {\n              width: width,\n              height: height\n            }\n          };\n          changes.push(dimensionChange);\n          prevValues.current.width = width;\n          prevValues.current.height = height;\n        }\n        if (changes.length === 0) {\n          return;\n        }\n        const direction = getDirection({\n          width: prevValues.current.width,\n          prevWidth,\n          height: prevValues.current.height,\n          prevHeight,\n          invertX,\n          invertY\n        });\n        const nextValues = {\n          ...prevValues.current,\n          direction\n        };\n        const callResize = shouldResize?.(event, nextValues);\n        if (callResize === false) {\n          return;\n        }\n        onResize?.(event, nextValues);\n        triggerNodeChanges(changes);\n      }\n    }).on('end', event => {\n      const dimensionChange = {\n        id: id,\n        type: 'dimensions',\n        resizing: false\n      };\n      onResizeEnd?.(event, {\n        ...prevValues.current\n      });\n      store.getState().triggerNodeChanges([dimensionChange]);\n    });\n    selection.call(dragHandler);\n    return () => {\n      selection.on('.drag', null);\n    };\n  }, [id, controlPosition, minWidth, minHeight, maxWidth, maxHeight, keepAspectRatio, getPointerPosition, onResizeStart, onResize, onResizeEnd]);\n  const positionClassNames = controlPosition.split('-');\n  const colorStyleProp = variant === ResizeControlVariant.Line ? 'borderColor' : 'backgroundColor';\n  const controlStyle = color ? {\n    ...style,\n    [colorStyleProp]: color\n  } : style;\n  return React.createElement(\"div\", {\n    className: cc(['react-flow__resize-control', 'nodrag', ...positionClassNames, variant, className]),\n    ref: resizeControlRef,\n    style: controlStyle\n  }, children);\n}\nvar ResizeControl$1 = memo(ResizeControl);\nconst handleControls = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst lineControls = ['top', 'right', 'bottom', 'left'];\nfunction NodeResizer(_ref3) {\n  let {\n    nodeId,\n    isVisible = true,\n    handleClassName,\n    handleStyle,\n    lineClassName,\n    lineStyle,\n    color,\n    minWidth = 10,\n    minHeight = 10,\n    maxWidth = Number.MAX_VALUE,\n    maxHeight = Number.MAX_VALUE,\n    keepAspectRatio = false,\n    shouldResize,\n    onResizeStart,\n    onResize,\n    onResizeEnd\n  } = _ref3;\n  if (!isVisible) {\n    return null;\n  }\n  return React.createElement(React.Fragment, null, lineControls.map(c => React.createElement(ResizeControl$1, {\n    key: c,\n    className: lineClassName,\n    style: lineStyle,\n    nodeId: nodeId,\n    position: c,\n    variant: ResizeControlVariant.Line,\n    color: color,\n    minWidth: minWidth,\n    minHeight: minHeight,\n    maxWidth: maxWidth,\n    maxHeight: maxHeight,\n    onResizeStart: onResizeStart,\n    keepAspectRatio: keepAspectRatio,\n    shouldResize: shouldResize,\n    onResize: onResize,\n    onResizeEnd: onResizeEnd\n  })), handleControls.map(c => React.createElement(ResizeControl$1, {\n    key: c,\n    className: handleClassName,\n    style: handleStyle,\n    nodeId: nodeId,\n    position: c,\n    color: color,\n    minWidth: minWidth,\n    minHeight: minHeight,\n    maxWidth: maxWidth,\n    maxHeight: maxHeight,\n    onResizeStart: onResizeStart,\n    keepAspectRatio: keepAspectRatio,\n    shouldResize: shouldResize,\n    onResize: onResize,\n    onResizeEnd: onResizeEnd\n  })));\n}\nexport { ResizeControl$1 as NodeResizeControl, NodeResizer, ResizeControlVariant };","map":{"version":3,"names":["React","memo","useRef","useEffect","cc","drag","select","useNodeId","useStoreApi","useGetPointerPosition","clamp","ResizeControlVariant","getDirection","_ref","width","prevWidth","height","prevHeight","invertX","invertY","deltaWidth","deltaHeight","direction","initPrevValues","x","y","initStartValues","pointerX","pointerY","aspectRatio","ResizeControl","_ref2","nodeId","position","variant","Handle","className","style","children","color","minWidth","minHeight","maxWidth","Number","MAX_VALUE","maxHeight","keepAspectRatio","shouldResize","onResizeStart","onResize","onResizeEnd","contextNodeId","id","store","resizeControlRef","startValues","prevValues","getPointerPosition","defaultPosition","Line","controlPosition","current","selection","enableX","includes","enableY","dragHandler","on","event","node","getState","nodeInternals","get","xSnapped","ySnapped","triggerNodeChanges","changes","startX","startY","startWidth","startHeight","startNodeX","startNodeY","prevX","prevY","distX","Math","floor","distY","nextAspectRatio","isDiagonal","isHorizontal","isVertical","isWidthChange","isHeightChange","isXPosChange","isYPosChange","positionChange","type","push","dimensionChange","updateStyle","resizing","dimensions","length","nextValues","callResize","call","positionClassNames","split","colorStyleProp","controlStyle","createElement","ref","ResizeControl$1","handleControls","lineControls","NodeResizer","_ref3","isVisible","handleClassName","handleStyle","lineClassName","lineStyle","Fragment","map","c","key","NodeResizeControl"],"sources":["/Users/mohamadali/Vitruv-UI-Methodologist/node_modules/@reactflow/node-resizer/dist/esm/index.mjs"],"sourcesContent":["import React, { memo, useRef, useEffect } from 'react';\nimport cc from 'classcat';\nimport { drag } from 'd3-drag';\nimport { select } from 'd3-selection';\nimport { useNodeId, useStoreApi, useGetPointerPosition, clamp } from '@reactflow/core';\n\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\n\n// returns an array of two numbers (0, 1 or -1) representing the direction of the resize\n// 0 = no change, 1 = increase, -1 = decrease\nfunction getDirection({ width, prevWidth, height, prevHeight, invertX, invertY }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n    if (deltaWidth && invertX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && invertY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n\nconst initPrevValues = { width: 0, height: 0, x: 0, y: 0 };\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1,\n};\nfunction ResizeControl({ nodeId, position, variant = ResizeControlVariant.Handle, className, style = {}, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd, }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === 'string' ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = useRef(null);\n    const startValues = useRef(initStartValues);\n    const prevValues = useRef(initPrevValues);\n    const getPointerPosition = useGetPointerPosition();\n    const defaultPosition = variant === ResizeControlVariant.Line ? 'right' : 'bottom-right';\n    const controlPosition = position ?? defaultPosition;\n    useEffect(() => {\n        if (!resizeControlRef.current || !id) {\n            return;\n        }\n        const selection = select(resizeControlRef.current);\n        const enableX = controlPosition.includes('right') || controlPosition.includes('left');\n        const enableY = controlPosition.includes('bottom') || controlPosition.includes('top');\n        const invertX = controlPosition.includes('left');\n        const invertY = controlPosition.includes('top');\n        const dragHandler = drag()\n            .on('start', (event) => {\n            const node = store.getState().nodeInternals.get(id);\n            const { xSnapped, ySnapped } = getPointerPosition(event);\n            prevValues.current = {\n                width: node?.width ?? 0,\n                height: node?.height ?? 0,\n                x: node?.position.x ?? 0,\n                y: node?.position.y ?? 0,\n            };\n            startValues.current = {\n                ...prevValues.current,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.current.width / prevValues.current.height,\n            };\n            onResizeStart?.(event, { ...prevValues.current });\n        })\n            .on('drag', (event) => {\n            const { nodeInternals, triggerNodeChanges } = store.getState();\n            const { xSnapped, ySnapped } = getPointerPosition(event);\n            const node = nodeInternals.get(id);\n            if (node) {\n                const changes = [];\n                const { pointerX: startX, pointerY: startY, width: startWidth, height: startHeight, x: startNodeX, y: startNodeY, aspectRatio, } = startValues.current;\n                const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues.current;\n                const distX = Math.floor(enableX ? xSnapped - startX : 0);\n                const distY = Math.floor(enableY ? ySnapped - startY : 0);\n                let width = clamp(startWidth + (invertX ? -distX : distX), minWidth, maxWidth);\n                let height = clamp(startHeight + (invertY ? -distY : distY), minHeight, maxHeight);\n                if (keepAspectRatio) {\n                    const nextAspectRatio = width / height;\n                    const isDiagonal = enableX && enableY;\n                    const isHorizontal = enableX && !enableY;\n                    const isVertical = enableY && !enableX;\n                    width = (nextAspectRatio <= aspectRatio && isDiagonal) || isVertical ? height * aspectRatio : width;\n                    height = (nextAspectRatio > aspectRatio && isDiagonal) || isHorizontal ? width / aspectRatio : height;\n                    if (width >= maxWidth) {\n                        width = maxWidth;\n                        height = maxWidth / aspectRatio;\n                    }\n                    else if (width <= minWidth) {\n                        width = minWidth;\n                        height = minWidth / aspectRatio;\n                    }\n                    if (height >= maxHeight) {\n                        height = maxHeight;\n                        width = maxHeight * aspectRatio;\n                    }\n                    else if (height <= minHeight) {\n                        height = minHeight;\n                        width = minHeight * aspectRatio;\n                    }\n                }\n                const isWidthChange = width !== prevWidth;\n                const isHeightChange = height !== prevHeight;\n                if (invertX || invertY) {\n                    const x = invertX ? startNodeX - (width - startWidth) : startNodeX;\n                    const y = invertY ? startNodeY - (height - startHeight) : startNodeY;\n                    // only transform the node if the width or height changes\n                    const isXPosChange = x !== prevX && isWidthChange;\n                    const isYPosChange = y !== prevY && isHeightChange;\n                    if (isXPosChange || isYPosChange) {\n                        const positionChange = {\n                            id: node.id,\n                            type: 'position',\n                            position: {\n                                x: isXPosChange ? x : prevX,\n                                y: isYPosChange ? y : prevY,\n                            },\n                        };\n                        changes.push(positionChange);\n                        prevValues.current.x = positionChange.position.x;\n                        prevValues.current.y = positionChange.position.y;\n                    }\n                }\n                if (isWidthChange || isHeightChange) {\n                    const dimensionChange = {\n                        id: id,\n                        type: 'dimensions',\n                        updateStyle: true,\n                        resizing: true,\n                        dimensions: {\n                            width: width,\n                            height: height,\n                        },\n                    };\n                    changes.push(dimensionChange);\n                    prevValues.current.width = width;\n                    prevValues.current.height = height;\n                }\n                if (changes.length === 0) {\n                    return;\n                }\n                const direction = getDirection({\n                    width: prevValues.current.width,\n                    prevWidth,\n                    height: prevValues.current.height,\n                    prevHeight,\n                    invertX,\n                    invertY,\n                });\n                const nextValues = { ...prevValues.current, direction };\n                const callResize = shouldResize?.(event, nextValues);\n                if (callResize === false) {\n                    return;\n                }\n                onResize?.(event, nextValues);\n                triggerNodeChanges(changes);\n            }\n        })\n            .on('end', (event) => {\n            const dimensionChange = {\n                id: id,\n                type: 'dimensions',\n                resizing: false,\n            };\n            onResizeEnd?.(event, { ...prevValues.current });\n            store.getState().triggerNodeChanges([dimensionChange]);\n        });\n        selection.call(dragHandler);\n        return () => {\n            selection.on('.drag', null);\n        };\n    }, [\n        id,\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        getPointerPosition,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n    ]);\n    const positionClassNames = controlPosition.split('-');\n    const colorStyleProp = variant === ResizeControlVariant.Line ? 'borderColor' : 'backgroundColor';\n    const controlStyle = color ? { ...style, [colorStyleProp]: color } : style;\n    return (React.createElement(\"div\", { className: cc(['react-flow__resize-control', 'nodrag', ...positionClassNames, variant, className]), ref: resizeControlRef, style: controlStyle }, children));\n}\nvar ResizeControl$1 = memo(ResizeControl);\n\nconst handleControls = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst lineControls = ['top', 'right', 'bottom', 'left'];\nfunction NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd, }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (React.createElement(React.Fragment, null,\n        lineControls.map((c) => (React.createElement(ResizeControl$1, { key: c, className: lineClassName, style: lineStyle, nodeId: nodeId, position: c, variant: ResizeControlVariant.Line, color: color, minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight, onResizeStart: onResizeStart, keepAspectRatio: keepAspectRatio, shouldResize: shouldResize, onResize: onResize, onResizeEnd: onResizeEnd }))),\n        handleControls.map((c) => (React.createElement(ResizeControl$1, { key: c, className: handleClassName, style: handleStyle, nodeId: nodeId, position: c, color: color, minWidth: minWidth, minHeight: minHeight, maxWidth: maxWidth, maxHeight: maxHeight, onResizeStart: onResizeStart, keepAspectRatio: keepAspectRatio, shouldResize: shouldResize, onResize: onResize, onResizeEnd: onResizeEnd })))));\n}\n\nexport { ResizeControl$1 as NodeResizeControl, NodeResizer, ResizeControlVariant };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}